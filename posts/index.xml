<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Corner case</title><link>https://freizl.github.io/posts/</link><description>Recent content in Posts on Corner case</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Haisheng Wu</copyright><lastBuildDate>Fri, 10 Sep 2021 15:33:00 -0700</lastBuildDate><atom:link href="https://freizl.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Hello Hugo</title><link>https://freizl.github.io/posts/hello-hugo/</link><pubDate>Fri, 10 Sep 2021 15:33:00 -0700</pubDate><guid>https://freizl.github.io/posts/hello-hugo/</guid><description>This is my first blog The content is generated from Org file.</description></item><item><title>Improve Space Usage</title><link>https://freizl.github.io/posts/improve-space-usage/</link><pubDate>Wed, 12 Sep 2012 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/improve-space-usage/</guid><description>It is example from [programming in haskell] video lecture 12 by Eric M. I just like to know whether GHC profile tool could help to figure out such problem.
module Main where sumWith1 v [] = v sumWith1 v (x:xs) = sumWith1 (v+x) xs sumWith2 v [] = v sumWith2 v (x:xs) = (sumWith2 $! (v+x)) xs test = sumWith2 0 [1..20000000] main = print test</description></item><item><title>Snaplet Request Local State</title><link>https://freizl.github.io/posts/snaplet-request-local-state/</link><pubDate>Thu, 24 May 2012 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/snaplet-request-local-state/</guid><description>什么 Snaplet Snap 从 0.6 版本引入 Snaplet 这个设计，它使得 Web 应用什么可组合化，开发者可以设计许多独立的功能模块，或者说小的应用模块，然后通过组合以组建一个大型的应用。
详细资料请看这里1。
Request local state Request Local State 是 snaplet 的一个设计目标2。初识时并没引起什么关注，也是不太理解具体含义。最近在写 Snaplet-OAuth 的时候遇到问题，就是由于不知道这个东西的含义所造成的。
Snaplet-oauth-0.0.0 根据 Snaplet 的常规模式，定义一个 data type 用于保存相关信息，比如
data OAuthSnaplet = OAuthSnaplet { getOauth :: OAuth2 , getCodeParam :: BS.ByteString } class HasOauth b where oauthLens :: Lens b (Snaplet OAuthSnaplet) data OAuth2 = OAuth2 { oauthClientId :: BS.ByteString , oauthClientSecret :: BS.ByteString , oauthOAuthorizeEndpoint :: BS.ByteString , oauthAccessTokenEndpoint :: BS.</description></item><item><title>Chinese Tag In Hakyll</title><link>https://freizl.github.io/posts/chinese-tag-in-hakyll/</link><pubDate>Thu, 26 Apr 2012 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/chinese-tag-in-hakyll/</guid><description>此问题发生在 GHC &amp;lt; 7.2.x 的环境，据说 7.2.x 已经修正了造成此原因的 bug(未验证)。
问题 Hakyll1会给每个标签单独生成一个 html，比如/foo.html/, 用来显示标签对应的所有文章。 然而当标签为中文时，文件名会是乱码，而非对应的中文标签名。
原因 造成问题是原因由于 Haskell 里写文件的方法。 如下所是，=writeFile=用 base 库里的=String=类型表示文件名， 这就限制其只能表示 ASC-II 字符集。
type FilePath = String writeFile :: FilePath -- ^ 文件名 -&amp;gt; String -- ^ 要写到文件的内容 -&amp;gt; IO () 一种解决办法 最直接的方式就是用类库 utf8-string2里的=encodeString=方法，现将文件名进行 encode 然后再调=writeFile=方法。比如
import qualified Codec.Binary.UTF8.String as UTF8 main = myWriteFile &amp;#34;新天地.html&amp;#34; &amp;#34;test&amp;#34; myWriteFile = writeFile . UTF8.encodeString 对应到 Hakyll, 就是将上述的改动加到这个文件里/src/Hakyll/Core/Writable.hs/.详见这里3.
再一种解决办法 hakyll goole groups 有人帖了他的一个解决方案，也是用 utf8-string 先 encode，但修改的地方不一样。详见此4。</description></item><item><title>Confused Constructor Js</title><link>https://freizl.github.io/posts/confused-constructor-js/</link><pubDate>Thu, 12 Apr 2012 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/confused-constructor-js/</guid><description>Introduction I can not quite remember what happened when invoking new over a function. While I&amp;rsquo;m looking at function init at jQuery source, the concern comes to me again.
Fourtunaly I think the answer at this1 thread turns out to be a quite clear explanation.
Just three things according to that answer.
Creates a new object. Its type is object. Sets this new object&amp;rsquo;s internal, inaccessible, [[prototype]] property to be the constructor function&amp;rsquo;s external, accessible, prototype object.</description></item><item><title>Git One Commit</title><link>https://freizl.github.io/posts/git-one-commit/</link><pubDate>Thu, 12 Apr 2012 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/git-one-commit/</guid><description>Play it new two files haiswu@haiswu-VirtualBox:~/github/haisheng-homepage/test$ echo &amp;#34;11111&amp;#34; &amp;gt; 1.txt haiswu@haiswu-VirtualBox:~/github/haisheng-homepage/test$ echo &amp;#34;22222&amp;#34; &amp;gt; 2.txt git-add haiswu@haiswu-VirtualBox:~/github/haisheng-homepage/test$ git add . haiswu@haiswu-VirtualBox:~/github/haisheng-homepage/test$ git st # On branch master # # Initial commit # # Changes to be committed: # (use &amp;#34;git rm --cached &amp;lt;file&amp;gt;...&amp;#34; to unstage) # # new file: 1.txt # new file: 2.txt # no objects created yet haiswu@haiswu-VirtualBox:~/github/haisheng-homepage/test$ git rev-list --objects --all git-commit haiswu@haiswu-VirtualBox:~/github/haisheng-homepage/test$ git ci &amp;#34;first commit&amp;#34; [master (root-commit) 8ef1919] first commit 2 files changed, 2 insertions(+), 0 deletions(-) create mode 100644 1.</description></item><item><title>Magic Monad Transformer</title><link>https://freizl.github.io/posts/magic-monad-transformer/</link><pubDate>Sat, 07 Apr 2012 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/magic-monad-transformer/</guid><description>Monad-Transformer The code fragment below is from chapter 18 Monad Transform of 1.
When the first time I read this example, I was confused with how it is possible to use ask of MonadReader (line 6) and get of MonadState (line 13) functions in the same App Monad content.
The only reasonable explanation is that App is both MonadReader and MonadState. While looking at App type definition (line 1), seems it is not possible.</description></item><item><title>Bayesian Network Exe01</title><link>https://freizl.github.io/posts/bayesian-network-exe01/</link><pubDate>Fri, 06 Apr 2012 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/bayesian-network-exe01/</guid><description>Introduction AI Course Bayesian network excerice 01 resolution using enumeration method.
C 国家政策 U 学校政策 W 工作压力 B 身体状况 D 过劳死 Scenarios 已知 : Exercise01 求 : 当 学校政策＝＝ True 而且 工作压力 == True 时, 过劳死的概率. Resolution Value T:0.95 means True case with probability 0.95
Probability of C is omitted as it is not related. Even include C, the result should be same.</description></item><item><title>Bind Examples In Javascripts</title><link>https://freizl.github.io/posts/bind-examples-in-javascripts/</link><pubDate>Fri, 06 Apr 2012 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/bind-examples-in-javascripts/</guid><description>Defined a function var fn = function (x, y, z) { console.log(&amp;#34;The value: &amp;#34;, this.shangHai); console.log(&amp;#34;The sum is: &amp;#34;, x + y + z); }; Run it fn(1); -&amp;gt; Output
The value: undefined The sum is: NaN fn(1, 2, 3); -&amp;gt; Output:
The value: undefined The sum is: 6 Run it with bind Less fn.bind(null, 1, 2, 3); -&amp;gt; Output:
function () { [native code] } Hmm&amp;hellip;, seems bind return a function rather apply the function and return value.</description></item><item><title>Export Orgmode File In Chinese</title><link>https://freizl.github.io/posts/export-orgmode-file-in-chinese/</link><pubDate>Fri, 06 Apr 2012 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/export-orgmode-file-in-chinese/</guid><description>Introduction OrgMode is really cool and export context to latex then processed to PDF is quite straightforwards. However when working with Chinese characters, I need additional packages.
First of all, install the following packages. (I already install the texlive package)
apt-get install latex-cjk-chinese latex-cjk-xcjk texlive-xetex First solution Then in the org file, add the following latex options.
#+LaTeX_HEADER: \usepackage{CJK} #+LaTeX_HEADER: \begin{CJK}{UTF8}{gbsn} One drawback is the \begin{CJK} is added as a header option but it does not have close tag.</description></item><item><title>Expression And Statement</title><link>https://freizl.github.io/posts/expression-and-statement/</link><pubDate>Fri, 06 Apr 2012 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/expression-and-statement/</guid><description>Expression Something which evaluates to a value. Example:
1 + 2/x Statement A line of code which does something. Example:
a = 1 + a; return 10; Reference Discussion at Stackoverflow Statement Expression</description></item><item><title>Git Svn</title><link>https://freizl.github.io/posts/git-svn/</link><pubDate>Fri, 06 Apr 2012 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/git-svn/</guid><description>git svn init/fetch git svn init [-s] URL git svn fetch -r xxx|HEAD a) it gets out &amp;#39;all&amp;#39; branches/tags/trunk when no specific -r b) by change some at branch, chdir to branches folder and play with git c) if specify with -r, means &amp;#34;Just want to checkout that revision&amp;#34; then try git svn rebase to update to HEAD git svn rebase git svn clone # if any problems with init/fetch, just clone and seems this is recommanded.</description></item><item><title>Git Tips</title><link>https://freizl.github.io/posts/git-tips/</link><pubDate>Fri, 06 Apr 2012 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/git-tips/</guid><description>fetch ### fetch origin &amp;#34;FROM&amp;#34; : &amp;#34;TO&amp;#34; fetch = +refs/heads/master:refs/remotes/origin/master git fetch origin master:refs/remotes/origin/mymaster git fetch origin master:refs/remotes/origin/mymaster topic:refs/remotes/origin/topic one commit What happened after one commit
log miscs git instaweb --httpd=lighttpd ### anything need push git remote show origin ### init new repos git clone --bare my_project my_project.git git reset --hard 7e83 git checkout 82f5 [-b branch_name] This takes you back in time, while preserving newer commits. git checkout :/&amp;#34;my first brach&amp;#34; Jump to the commit that starts with a given message.</description></item><item><title>Perl Tips</title><link>https://freizl.github.io/posts/perl-tips/</link><pubDate>Fri, 06 Apr 2012 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/perl-tips/</guid><description>Basic my @myarray = (); push @myarray,&amp;#34;a&amp;#34;; my @keys = qw(a b c); my @vals = (1, 2, 3); my %hash; @hash{@keys} = @vals; Loop # loop elements in itemArray1 and itemArray2 foreach my $item (@itemArray1, @itemArray2) { ... } while ( my ($key, $value) = each(%hash) ) { print &amp;#34;$key =&amp;gt; $value\n&amp;#34;; } Sub sub prepare_sth { my $param = shift; # means shift @_, @_ is param array # my $param = $_; # when could use $_ ?</description></item><item><title>Python Tips</title><link>https://freizl.github.io/posts/python-tips/</link><pubDate>Fri, 06 Apr 2012 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/python-tips/</guid><description>re &amp;gt;&amp;gt;&amp;gt; re.split(&amp;#34;[^0-9]&amp;#34;, &amp;#34;12 34 + 2 *&amp;#34;) [&amp;#39;12&amp;#39;, &amp;#39;34&amp;#39;, &amp;#39;&amp;#39;, &amp;#39;&amp;#39;, &amp;#39;2&amp;#39;, &amp;#39;&amp;#39;, &amp;#39;&amp;#39;] Cant understand how '' being produced.
list str(&amp;#34;abcdef&amp;#34;)[::-1] ==&amp;gt; &amp;#34;fedcba&amp;#34; reduce(lambda x,y:y+x,&amp;#34;abcdef&amp;#34;) ==&amp;gt; &amp;#34;fedcba&amp;#34; sorted([1,5,3,2]) ==&amp;gt; [1,2,3,5] a = [1,5,3,2]; a.sort() ==&amp;gt; a := [1,2,3,5] dict ### demostrate loop a dict and list/dict parameter def tst_dict(*args, **kargs): for k, v in dict(*args, **kargs).iteritems(): print k, v def tst_dict2(): for key in a_dict: print key, a_dict[key] tst_dict(name=&amp;#39;aa&amp;#39;, place=&amp;#39;bb&amp;#39;) tst_dict(&amp;#39;aaa&amp;#39;, &amp;#39;bbb&amp;#39;) # throw error Mise range(4) ==&amp;gt; [0,1,2,3] #range start from 0 by default &amp;#39;%s: %r&amp;#39; % (something, other) &amp;#39;%(name)sis %(value)d&amp;#39; % { &amp;#39;name&amp;#39;: &amp;#39;The answer&amp;#39;, &amp;#39;value&amp;#39;: 42, } Reference re reference</description></item><item><title>Shell Tips</title><link>https://freizl.github.io/posts/shell-tips/</link><pubDate>Fri, 06 Apr 2012 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/shell-tips/</guid><description>Quicklinks What is a Subshell List of Unix utilities 10 Good Unix habits Reference () execute command in subshell {} execute command in currecnt shell Usage is same with () expect the final command in the list ends with a semicolon. Sample Section A grep grep -Elr --include=*.xsd --exclude-dir={branches,tags} VendorDesc.xsd $DIRECTORY ### count process and exclude grep itself ps aux | grep vpnc | grep -v grep -c find find ${1} \( -name Consume*wsdl -o -name Produce*wsdl \) -path *trunk* find $update_dir \( -name &amp;#39;*.</description></item><item><title>Euler Problem 104</title><link>https://freizl.github.io/posts/euler-problem-104/</link><pubDate>Thu, 15 Dec 2011 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/euler-problem-104/</guid><description>Solutions There are two solutions below. One is written by me and another from haskell wiki.
They look quite similar and I can not figure out why the wiki solution can solve problem but not mine. (Actually mine take more than 15 minutes)
My Solution main = print $ snd $ head $ dropWhile (\ (x,y) -&amp;gt; (not . isLastNinePandigit &amp;#34;123456789&amp;#34;) x) (zip fibs [1..]) bothNinePandigit digits n = isFirstNinePandigit digits n &amp;amp;&amp;amp; isLastNinePandigit digits n isLastNinePandigit digits = (== digits) .</description></item><item><title>Euler Problem 14</title><link>https://freizl.github.io/posts/euler-problem-14/</link><pubDate>Sun, 20 Nov 2011 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/euler-problem-14/</guid><description>Solution One I should say this solution only work while upper limit is under 100000. Otherwise it is really slow and I have no patient for the result. I wonder it would take minutes or even hours.
So, problem solving failed.
module Main where import Data.Word main :: IO () main = print $ p14 p14 = maximum [ (startChain n 0, n) | n &amp;lt;- [2..1000000] ] startChain :: Int -&amp;gt; Int -&amp;gt; Int startChain 1 count = count + 1 startChain n count = startChain (intTransform n) (count+1) intTransform :: Int -&amp;gt; Int intTransform n | even n = n `div` 2 | otherwise = 3 * n + 1 Compile as otherwise Stack space overflow : ghc --make p14-1.</description></item><item><title>One Solution To Euler 12</title><link>https://freizl.github.io/posts/one-solution-to-euler-12/</link><pubDate>Fri, 18 Nov 2011 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/one-solution-to-euler-12/</guid><description>Nothing special but play haskell for fun.
Priming is a simple module which can be found at 1
module Main where import Data.List import Primeing (primeFactors) main :: IO () main = print $ p12 500 p12 :: Int -&amp;gt; Int p12 n = head $ filter (factorLimit n) [ smartGaus x | x &amp;lt;- [1..]] smartGaus :: Int -&amp;gt; Int smartGaus n = (1+n)*n `div` 2 {-- | Is factor count under the limit --} factorLimit :: Int -&amp;gt; Int -&amp;gt; Bool factorLimit l n | 2 * sqrtInt n &amp;lt; l = False | otherwise = length (factors n) &amp;gt;= l factors :: Int -&amp;gt; [Int] factors n = concat [ [x, n `div` x] | x &amp;lt;- [1.</description></item><item><title>Type Parameter At Typeclass Instance</title><link>https://freizl.github.io/posts/type-parameter-at-typeclass-instance/</link><pubDate>Sat, 02 Jul 2011 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/type-parameter-at-typeclass-instance/</guid><description>A newbie concern A concern arise while I compare following two instances of Maybe.
class Eq a where (==) :: a -&amp;gt; a -&amp;gt; Bool (/=) :: a -&amp;gt; a -&amp;gt; Bool class Functor f where fmap :: (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b instance (Eq a) =&amp;gt; Eq (Maybe a) where Just x == Just y = x == y Nothing == Nothing = True _ == _ = False instance Functor Maybe where fmap f (Just x) = Just (f x) fmap f Nothing = Nothing It put Maybe as type parameter while instance Functor class.</description></item><item><title>Max File Size</title><link>https://freizl.github.io/posts/max-file-size/</link><pubDate>Tue, 21 Jun 2011 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/max-file-size/</guid><description>While doing some refactoring work on solution from this guy1, I realized a pretty trivial thing about Manod method &amp;gt;&amp;gt;=.
Take a look at its definition:
Prelude&amp;gt; :t (&amp;gt;&amp;gt;=) (&amp;gt;&amp;gt;=) :: (Monad m) =&amp;gt; m a -&amp;gt; (a -&amp;gt; m b) -&amp;gt; m b Both a and b ought to be some Monadic type! In other words, all computation glued together by &amp;gt;&amp;gt;= have same Manodic type.
It is really straightforward however I did not have that in mind.</description></item><item><title>Deriving</title><link>https://freizl.github.io/posts/deriving/</link><pubDate>Tue, 14 Jun 2011 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/deriving/</guid><description>Deriving What the cool thing that Deriving does is actually automaticlly implementing instance for perticular type class.
For instance, a Person derives Eq
data Person = Person { firstName :: String , lastName :: String , age :: Int } deriving Eq Then we are able to compare two Persons because Haskell make the type Person to be a instance of typeclass Eq.
Take another example,
data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday deriving (Bounded, Enum) The Bounded typeclass defines things that have lowest possible value and highest possible value.</description></item><item><title>MapM</title><link>https://freizl.github.io/posts/mapm/</link><pubDate>Tue, 14 Jun 2011 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/mapm/</guid><description>How to understand the following computation result? Prelude&amp;gt; mapM id [Just 1, Nothing, Just 3] Nothing &amp;lsquo;Reason about&amp;rsquo; mapM :: (a -&amp;gt; m b) -&amp;gt; [a] -&amp;gt; m [b] id :: a -&amp;gt; a sequence :: (Monad m) =&amp;gt; [m a] -&amp;gt; m [a] Therefore,
&amp;gt; a = Maybe Int &amp;gt; m = Maybe &amp;gt; b = Int the mapM and sequence is implemented like this:
mapM f xs = sequence (map f xs) sequence (c:cs) = do x &amp;lt;- c xs &amp;lt;- sequence cs return (x:xs) Hence the result could be understood in such way</description></item><item><title>Understand Foldr Operator</title><link>https://freizl.github.io/posts/understand-foldr-operator/</link><pubDate>Sat, 04 Jun 2011 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/understand-foldr-operator/</guid><description>I can not quite remember the usage of foldr until I finish the video by Erik Meijer on Chapter 71.
Descrption by Erik Erik describe foldr in a very comprehensive way.
Take refining the length function in terms of foldr as a example. length has a definition as
&amp;gt; length :: [a] -&amp;gt; Int &amp;gt; length [] = 0 &amp;gt; length (x:xs) = 1 + length xs and
length [1,2,3] = length (1:(2:(3:[]))) = 1 + (1 + (1 + 0)) = 3 By replace each (:) by \ _ n -&amp;gt; 1 + n and [] by 0, we have:</description></item><item><title>Yet another Haskell toturial - Exercise 3</title><link>https://freizl.github.io/posts/exe-3/</link><pubDate>Sat, 04 Jun 2011 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/exe-3/</guid><description>The exercise asks writing a program that will repeatedly ask the user for numbers until she types in zero, at which point it will tell her the sum of all the numbers, the product of all the numbers, and, for each number, its factorial.
In the solution, I practice a idea that Monad is lazy as well. In other words, here, could generate a list of Monads then print out to console.</description></item><item><title>A Really Trivial Monad</title><link>https://freizl.github.io/posts/a-really-trivial-monad/</link><pubDate>Sun, 29 May 2011 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/a-really-trivial-monad/</guid><description>Generally some people saying that Monad is a computation that take a &amp;lsquo;world&amp;rsquo; as parameter and produce a result along with modified &amp;lsquo;world&amp;rsquo;. And this a manner that doing impure in a pure language.
While thinking in terms of Parser, it means taking a String and produce a result along with the rest of the string which is not parsed1. Consequently, we think a monadic type in Haskell is just a function.</description></item><item><title>命理学基础知识</title><link>https://freizl.github.io/posts/basic-knowledge-of-mingli/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/basic-knowledge-of-mingli/</guid><description>五行 相生相克：金、水、木、火、土，顺序相生，隔序相克，非常简单易记。 五行相生：金生水，水生木，木生火，火生土，土生金。 五行相克：金克木，木克土，土克水，水克火，火克金。 天干地支 十天干：甲、乙、丙、丁、戊（wù）、己、庚（gēng）、辛、壬（rén）、癸（guǐ） 天干五行：甲乙木、丙丁火、戊己土、庚辛金、壬癸水 天干阴阳：甲丙戊庚壬为阳干，乙丁己辛癸为阴干 十二地支：子、丑、寅（yín）、卯（mǎo）、辰、巳、午、未、申、酉（yǒu）、戌（xū）、亥（hài） 地支五行：寅卯木、巳午火、申酉金、亥子水、丑未辰戌土 地支阴阳：子寅辰午申戌为阳支，丑卯巳未酉亥为阴支 十神 同性为偏，异性为正。 同我者比劫，我生者食伤，我克者才财，克我者杀官，生我者枭印。
1、同我者为比劫。同性为比肩，简称比；异性为劫财，简称劫。比如日干为甲，甲、寅为比肩，乙卯为劫财。 1、生我者为枭印。同性为偏印，也叫枭神，简称枭；异性为正印，简称印。比如日干为甲木，壬、亥为偏印，癸、子则为正印。 1、我生者为食伤。同性为食神，简称食；异性为伤官，简称伤。比如日干为甲，丙午为食神，丁巳为伤官。 1、我克者为才财。同性为偏财，简称财；异性为正财，简称才（贝）。比如日干为甲，戊、辰、戌土就是偏财，己、丑，未土就是正财。 1、克我者为杀官。同性为偏官，或者七杀，简称杀；异性为正官，简称官。比如日干为甲木，庚申为七杀，辛酉为正官。</description></item></channel></rss>