<!doctype html><html lang=en-us>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta http-equiv=x-ua-compatible content="IE=edge">
<style type=text/css>body{font-family:monospace}</style>
<title>Snaplet Request Local State</title>
<link rel=stylesheet href=../../css/style.css>
</head>
<body>
<header>
=================<br>
== <a href=https://freizl.github.io/>Corner case</a> ==<br>
=================
<div style=float:right>Welcome to my new blog!</div><br>
<p>
<nav>
<a href=../../><b>Start</b></a>.
</header>
<main>
<article>
<h1>Snaplet Request Local State</h1>
<b><time>05/24/2012</time></b>
<a href=../../tags/snap>snap</a>
<a href=../../tags/snaplet>snaplet</a>
<div>
<h2 id=什么-snaplet>什么 Snaplet</h2>
<p>Snap 从 0.6 版本引入 Snaplet 这个设计，它使得 Web
应用什么可组合化，开发者可以设计许多独立的功能模块，或者说小的应用模块，然后通过组合以组建一个大型的应用。</p>
<p>详细资料请看这里<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>。</p>
<h2 id=request-local-state>Request local state</h2>
<p><strong>Request Local State</strong> 是 snaplet
的一个设计目标<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>。初识时并没引起什么关注，也是不太理解具体含义。最近在写
Snaplet-OAuth 的时候遇到问题，就是由于不知道这个东西的含义所造成的。</p>
<h2 id=snaplet-oauth-0.0.0>Snaplet-oauth-0.0.0</h2>
<p>根据 Snaplet 的常规模式，定义一个 data type 用于保存相关信息，比如</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell>  <span style=color:#66d9ef>data</span> <span style=color:#66d9ef>OAuthSnaplet</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>OAuthSnaplet</span>
                      { getOauth     <span style=color:#f92672>::</span> <span style=color:#66d9ef>OAuth2</span>
                      , getCodeParam <span style=color:#f92672>::</span> <span style=color:#66d9ef>BS</span><span style=color:#f92672>.</span><span style=color:#66d9ef>ByteString</span>
                      }

  <span style=color:#66d9ef>class</span> <span style=color:#66d9ef>HasOauth</span> b <span style=color:#66d9ef>where</span>
      oauthLens <span style=color:#f92672>::</span> <span style=color:#66d9ef>Lens</span> b (<span style=color:#66d9ef>Snaplet</span> <span style=color:#66d9ef>OAuthSnaplet</span>)

  <span style=color:#66d9ef>data</span> <span style=color:#66d9ef>OAuth2</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>OAuth2</span> { oauthClientId <span style=color:#f92672>::</span> <span style=color:#66d9ef>BS</span><span style=color:#f92672>.</span><span style=color:#66d9ef>ByteString</span>
                       , oauthClientSecret <span style=color:#f92672>::</span> <span style=color:#66d9ef>BS</span><span style=color:#f92672>.</span><span style=color:#66d9ef>ByteString</span>
                       , oauthOAuthorizeEndpoint <span style=color:#f92672>::</span> <span style=color:#66d9ef>BS</span><span style=color:#f92672>.</span><span style=color:#66d9ef>ByteString</span>
                       , oauthAccessTokenEndpoint <span style=color:#f92672>::</span> <span style=color:#66d9ef>BS</span><span style=color:#f92672>.</span><span style=color:#66d9ef>ByteString</span>
                       , oauthCallback <span style=color:#f92672>::</span> <span style=color:#66d9ef>Maybe</span> <span style=color:#66d9ef>BS</span><span style=color:#f92672>.</span><span style=color:#66d9ef>ByteString</span>
                       , oauthAccessToken <span style=color:#f92672>::</span> <span style=color:#66d9ef>Maybe</span> <span style=color:#66d9ef>BS</span><span style=color:#f92672>.</span><span style=color:#66d9ef>ByteString</span>
                       } <span style=color:#66d9ef>deriving</span> (<span style=color:#66d9ef>Show</span>, <span style=color:#66d9ef>Eq</span>)
</code></pre></div><p>如果从 Monad State Trans 的角度去理解， =OAuthSnaplet=就是一个要成为
State 的一个用户类型。 =HasOauth=可以理解为用户和其他 Snaplet
组合的接口。</p>
<p>如下代码就展示了如果将 OAuthSnaplet
加入到一个新的应用程序。(其实就是另一个 Snaplet) 如果你已用过其他
Snaplet，这看上去会很熟悉、常规。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell>  <span style=color:#66d9ef>data</span> <span style=color:#66d9ef>App</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>App</span>
      { _weibo   <span style=color:#f92672>::</span> <span style=color:#66d9ef>Snaplet</span> <span style=color:#66d9ef>OAuthSnaplet</span>
      }

  makeLens <span style=color:#66d9ef>&#39;&#39;App</span>

  <span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>HasOauth</span> <span style=color:#66d9ef>App</span> <span style=color:#66d9ef>where</span>
     oauthLens <span style=color:#f92672>=</span> weibo
</code></pre></div><p>拿新浪微薄<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>举例，OAuth 的验证简单来说就是</p>
<ol>
<li>重定向到新浪微薄 OAuth 的验证页面，让用户授权</li>
<li>授权后新浪微薄会调用我们的 App 指定的 Callback URL</li>
<li>我们需要实现这个 Callback 已获取最终的 access token</li>
</ol>
<p>下面来看下这个 callback 的实现</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell>
  oauthCallbackHandler <span style=color:#f92672>::</span> <span style=color:#66d9ef>HasOauth</span> b
                       <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>Maybe</span> <span style=color:#66d9ef>BS</span><span style=color:#f92672>.</span><span style=color:#66d9ef>ByteString</span>
                       <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Handler</span> b b ()
  oauthCallbackHandler uri <span style=color:#f92672>=</span> <span style=color:#66d9ef>do</span>
      oauthSnaplet <span style=color:#f92672>&lt;-</span> getOauthSnaplet
      codeParam    <span style=color:#f92672>&lt;-</span> decodedParam&#39; (getCodeParam oauthSnaplet)
      oauth        <span style=color:#f92672>&lt;-</span> getOauth oauthSnaplet
      maybeToken   <span style=color:#f92672>&lt;-</span> liftIO <span style=color:#f92672>$</span> requestAccessToken oauth codeParam
      <span style=color:#66d9ef>case</span> maybeToken <span style=color:#66d9ef>of</span>
          <span style=color:#66d9ef>Just</span> token <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>do</span>
               updateOAuthSnaplet (modify <span style=color:#f92672>$</span> modifyOAuthState token)
               redirect <span style=color:#f92672>$</span> fromMaybe <span style=color:#e6db74>&#34;/&#34;</span> uri
          <span style=color:#66d9ef>_</span> <span style=color:#f92672>-&gt;</span> writeBS <span style=color:#e6db74>&#34;Error getting access token.&#34;</span>


  modifyOAuthState <span style=color:#f92672>::</span> <span style=color:#66d9ef>AccessToken</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>OAuthSnaplet</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>OAuthSnaplet</span>
  modifyOAuthState (<span style=color:#66d9ef>AccessToken</span> at) oa <span style=color:#f92672>=</span> <span style=color:#66d9ef>OAuthSnaplet</span> { getOauth <span style=color:#f92672>=</span> newOA, getCodeParam <span style=color:#f92672>=</span> getCodeParam oa }
                                         <span style=color:#66d9ef>where</span> newOA <span style=color:#f92672>=</span> originOA { oauthAccessToken <span style=color:#f92672>=</span> <span style=color:#66d9ef>Just</span> at }
                                               originOA <span style=color:#f92672>=</span> getOauth oa

  updateOAuthSnaplet <span style=color:#f92672>::</span> (<span style=color:#66d9ef>MonadSnaplet</span> m) <span style=color:#f92672>=&gt;</span> m b <span style=color:#66d9ef>OAuthSnaplet</span> a <span style=color:#f92672>-&gt;</span> m b <span style=color:#66d9ef>OAuthSnaplet</span> a
  updateOAuthSnaplet <span style=color:#f92672>=</span> with&#39; oauthLens
</code></pre></div><p>这里主要关注的是第 11 行到 13 行，=Just token=表示成功获取了
AccessToken，然后要</p>
<ol>
<li>将 OAuthSnpalet 里的 oauth 的 AccessToken 更新掉。</li>
<li>然后将更新后 OAuthSnaplet 替代掉原来的</li>
</ol>
<p>这样一来 OAuthSnaplet 就有 AccessToken，在往后的 Handler 都可以拿到这个
AcceeToken 来访问微薄资源。</p>
<p>然后事实并不是这样子，在这个 oauthCallbackHandler 对 OAuthSnaplet
的更新只限于这个 Handler。 <strong>因为 snap 是多线程的且线程安全，每一次的
request 都是对 snaplet 状态的一份新拷贝。</strong> 而由于初始化 OauthSnaplet
的时候是没有 AccessToken 的，这就意谓着所有的 Handler 默认读到的
AccessToken 是空的。</p>
<h2 id=如何解决>如何解决</h2>
<p>解决方案就是把=OAuthSnaplet=里的=oauth=变成一个共享变量，这样可以在多线程之间共享。</p>
<p>一种实现方式就是用=MVar=<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>，这样 OAuthSnaplet 就成了这样子</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell>  <span style=color:#66d9ef>data</span> <span style=color:#66d9ef>OAuthSnaplet</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>OAuthSnaplet</span>
                      { getOauth     <span style=color:#f92672>::</span> <span style=color:#66d9ef>MVar</span> <span style=color:#66d9ef>OAuth2</span>
                      , getCodeParam <span style=color:#f92672>::</span> <span style=color:#66d9ef>BS</span><span style=color:#f92672>.</span><span style=color:#66d9ef>ByteString</span>
                      }
</code></pre></div><p>然后就很直观了，用=Control.Concurrent=库里提供的更新一个 MVar
的方式来做更新和读取。 最后的实现可以参考这里<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>，不在这里累赘。</p>
<h2 id=还有什么问题>还有什么问题</h2>
<p>你可能已经发现，这样的实现方式，如何支持多用户，以及多个 OAuth Provider
呢？
我还没有答案，如果你知道怎么做，欢迎<a href=https://github.com/HaskellCNOrg/snaplet-oauth>send
Pull Request</a>.</p>
<section class=footnotes role=doc-endnotes>
<hr>
<ol>
<li id=fn:1 role=doc-endnote>
<p><a href=http://snapframework.com/docs/tutorials/snaplets-tutorial>Snaplets Tutorial</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:2 role=doc-endnote>
<p><a href=http://snapframework.com/docs/tutorials/snaplets-design>Snaplets-Design</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:3 role=doc-endnote>
<p><a href=http://open.weibo.com/wiki/%E6%8E%88%E6%9D%83%E6%9C%BA%E5%88%B6%E8%AF%B4%E6%98%8E>新浪微博授权机制说明</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:4 role=doc-endnote>
<p><a href=http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.1.0/Control-Concurrent-MVar.html>MVar</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:5 role=doc-endnote>
<p><a href=https://github.com/HaskellCNOrg/snaplet-oauth>Snaplet-OAuth in Github</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
</ol>
</section>
</div>
</article>
</main>
<aside>
<div>
<div>
<h3>LATEST POSTS</h3>
</div>
<div>
<ul>
<li><a href=../../posts/hello-hugo/>Hello Hugo</a></li>
<li><a href=../../posts/improve-space-usage/>Improve Space Usage</a></li>
<li><a href=../../posts/snaplet-request-local-state/>Snaplet Request Local State</a></li>
<li><a href=../../posts/chinese-tag-in-hakyll/>Chinese Tag In Hakyll</a></li>
<li><a href=../../posts/confused-constructor-js/>Confused Constructor Js</a></li>
</ul>
</div>
</div>
</aside>
<footer>
<p>&copy; 2021 <a href=https://freizl.github.io/><b>Haisheng Wu</b></a>.
</p>
</footer>
</body>
</html>