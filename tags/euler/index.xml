<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>euler on Corner case</title><link>https://freizl.github.io/tags/euler/</link><description>Recent content in euler on Corner case</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Haisheng Wu</copyright><lastBuildDate>Thu, 15 Dec 2011 00:00:00 +0000</lastBuildDate><atom:link href="https://freizl.github.io/tags/euler/index.xml" rel="self" type="application/rss+xml"/><item><title>Euler Problem 104</title><link>https://freizl.github.io/posts/euler-problem-104/</link><pubDate>Thu, 15 Dec 2011 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/euler-problem-104/</guid><description>Solutions There are two solutions below. One is written by me and another from haskell wiki.
They look quite similar and I can not figure out why the wiki solution can solve problem but not mine. (Actually mine take more than 15 minutes)
My Solution main = print $ snd $ head $ dropWhile (\ (x,y) -&amp;gt; (not . isLastNinePandigit &amp;#34;123456789&amp;#34;) x) (zip fibs [1..]) bothNinePandigit digits n = isFirstNinePandigit digits n &amp;amp;&amp;amp; isLastNinePandigit digits n isLastNinePandigit digits = (== digits) .</description></item><item><title>Euler Problem 14</title><link>https://freizl.github.io/posts/euler-problem-14/</link><pubDate>Sun, 20 Nov 2011 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/euler-problem-14/</guid><description>Solution One I should say this solution only work while upper limit is under 100000. Otherwise it is really slow and I have no patient for the result. I wonder it would take minutes or even hours.
So, problem solving failed.
module Main where import Data.Word main :: IO () main = print $ p14 p14 = maximum [ (startChain n 0, n) | n &amp;lt;- [2.</description></item><item><title>One Solution To Euler 12</title><link>https://freizl.github.io/posts/one-solution-to-euler-12/</link><pubDate>Fri, 18 Nov 2011 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/one-solution-to-euler-12/</guid><description>Nothing special but play haskell for fun.
Priming is a simple module which can be found atÂ 1
module Main where import Data.List import Primeing (primeFactors) main :: IO () main = print $ p12 500 p12 :: Int -&amp;gt; Int p12 n = head $ filter (factorLimit n) [ smartGaus x | x &amp;lt;- [1..]] smartGaus :: Int -&amp;gt; Int smartGaus n = (1+n)*n `div` 2 {-- | Is factor count under the limit --} factorLimit :: Int -&amp;gt; Int -&amp;gt; Bool factorLimit l n | 2 * sqrtInt n &amp;lt; l = False | otherwise = length (factors n) &amp;gt;= l factors :: Int -&amp;gt; [Int] factors n = concat [ [x, n `div` x] | x &amp;lt;- [1.</description></item><item><title>Euler Problem 28</title><link>https://freizl.github.io/posts/euler-problem-28/</link><pubDate>Tue, 13 Jan 2009 05:42:00 -0800</pubDate><guid>https://freizl.github.io/posts/euler-problem-28/</guid><description>problem 28
&amp;quot;&amp;quot;&amp;quot; Mathmatics method
S1 = 1
S2 = 1 + 1 * (8*2*2 - 2 + 6) * 2 / 3 = 1 + 24 = 25
Sn = S1 + (Pn-1 + n-1) + (Pn-1 + (n-1)*2) + (Pn-1 + (n-1)*3) + (Pn-1 + (n-1)*4)
= S1 + 4 * Pn-1 + (2*n - 2)*10
= S1 + 16*{ sigma:X^2 | n-1 &amp;gt;= X &amp;gt;= 1 } + 4*{ sigma:X | n-1 &amp;gt;= X &amp;gt;= 1 } + 4*(n-1)</description></item></channel></rss>