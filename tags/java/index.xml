<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on Corner case</title><link>https://freizl.github.io/tags/java/</link><description>Recent content in Java on Corner case</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Haisheng Wu</copyright><lastBuildDate>Tue, 10 Aug 2010 07:02:00 -0700</lastBuildDate><atom:link href="https://freizl.github.io/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>"Operation" Enum</title><link>https://freizl.github.io/posts/operation-enum/</link><pubDate>Tue, 10 Aug 2010 07:02:00 -0700</pubDate><guid>https://freizl.github.io/posts/operation-enum/</guid><description>public enum Operation { PLUS { double eval(double x, double y) { return x + y; } }, MINUS { double eval(double x, double y) { return x - y; } }, TIMES { double eval(double x, double y) { return x \* y; } }, DIVIDED\_BY { double eval(double x, double y) { return x / y; } }; // Perform the arithmetic operation represented by this constant abstract double eval(double x, double y); public static void main(String args\[\]) { double x = 2.</description></item><item><title>Increment/Decrement operators</title><link>https://freizl.github.io/posts/incrementdecrement-operators/</link><pubDate>Tue, 10 Aug 2010 05:54:00 -0700</pubDate><guid>https://freizl.github.io/posts/incrementdecrement-operators/</guid><description>The increment/decrement operators can be applied before (prefix) or after (postfix) the operand.
The code result++; and ++result; will both end in result being incremented by one.
The only difference is thatthe prefix version (++result) evaluates to the incremented value,
whereas the postfix version (result++) evaluates to the original value.
If you are just performing a simple increment/decrement, it doesn&amp;rsquo;t really matter which version you choose.
But if you use this operator in part of a larger expression, the one that you choose may make a significant difference.</description></item><item><title>Refactoring StockWatcher in MVP</title><link>https://freizl.github.io/posts/refactoring-stockwatcher-in-mvp/</link><pubDate>Sun, 13 Jun 2010 00:15:00 -0700</pubDate><guid>https://freizl.github.io/posts/refactoring-stockwatcher-in-mvp/</guid><description>GWT get started tutorial has a sample project StockWatcher and I got refactoring it in a MVP way.
StockWatcher in MVP StockWatcher in MVP with UiBinder Reference:
GWT get started
MVP Architecture</description></item><item><title>Patterns: Factory method,Template method and Strategy</title><link>https://freizl.github.io/posts/patterns-factory-methodtemplate-method/</link><pubDate>Tue, 01 Sep 2009 21:30:00 -0700</pubDate><guid>https://freizl.github.io/posts/patterns-factory-methodtemplate-method/</guid><description>Basically, Factory method is a method that is defined in Parent class and is implemented in Child class, which usually is abstract method.
By contract, Template method is a method that implements an &amp;ldquo;algorithm&amp;rdquo;. This implementation is usually defined in a &amp;ldquo;Parent&amp;rdquo; class and leveraging other methods including Factory methods. (See sample below)
public abstract class PizzaStore {
/**
* #templateMethod(String type) is an Template Method.
* * #factoryMethodOfInit() AND #factoryMethodOfCreate(String type) are both</description></item><item><title>Hermes vs Oracle AQ</title><link>https://freizl.github.io/posts/hermes-vs-oracle-aq/</link><pubDate>Sun, 12 Oct 2008 18:10:00 -0700</pubDate><guid>https://freizl.github.io/posts/hermes-vs-oracle-aq/</guid><description>1. Need a wrapped connect factory, see here. And package it into a jar, like oracleaq-factory.jar
2. How to in Hermes:
 2.1 add a new provider including those jars: aqapi.jar, jms.jar, jta.jar, ojdbc.jar and oracleaq-factory.jar
2.2 create a new session for AQ topic (EAB_DEMO_QUEUE here):
3. Double click the topic under the session, EAB_DEMO_QUEUE here, to connect to the topic.
Hermes will create a new subscriber for this topic.</description></item><item><title>Interactive with AQ Topic in Java</title><link>https://freizl.github.io/posts/interactive-with-aq-topic-in-java/</link><pubDate>Sun, 21 Sep 2008 19:19:00 -0700</pubDate><guid>https://freizl.github.io/posts/interactive-with-aq-topic-in-java/</guid><description>import static org.junit.Assert.assertNotNull;
import java.util.Calendar;
import javax.jms.Message;
import javax.jms.QueueConnection;
import javax.jms.QueueConnectionFactory;
import javax.jms.Topic;
import oracle.jms.AQjmsAgent;
import oracle.jms.AQjmsFactory;
import oracle.jms.AQjmsSession;
import oracle.jms.AQjmsTextMessage;
import oracle.jms.AQjmsTopicPublisher;
import oracle.jms.AQjmsTopicReceiver;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
public class TestOracleAQ {
private static final String AQ_TOPIC = &amp;ldquo;ESB_DEMO_QUEUE&amp;rdquo;;
/** AQ Server Connection */
private static final String HOST_NAME = &amp;ldquo;VLINUX&amp;rdquo;;
private static final String SID = &amp;ldquo;XE&amp;rdquo;;
private static final int CONNECT_PORT = 1521;
private static final String CONNECT_TYPE = &amp;ldquo;thin&amp;rdquo;;</description></item><item><title>"Instance" an Interface (Java)</title><link>https://freizl.github.io/posts/instance-interface-java/</link><pubDate>Sun, 20 Jul 2008 05:26:00 -0700</pubDate><guid>https://freizl.github.io/posts/instance-interface-java/</guid><description>It looks like &amp;ldquo;instance&amp;rdquo; an Interface&amp;hellip;
import static org.junit.Assert.assertTrue;
import org.junit.Test;
public class InterestingTests {
 @Test
public void TestConstructInterface() {
TurnstileController controller = new TurnstileController() {
private boolean lockState = false;
private boolean unlockState = false;
 public void lock() {
lockState = true;
}
 public void unlock() {
unlockState = true;
}
 public boolean isLockState() {
return lockState;
}
 public boolean isUnlockState() {
return unlockState;</description></item><item><title>Something in Generic Programming</title><link>https://freizl.github.io/posts/something-in-generic-programming/</link><pubDate>Wed, 16 Jul 2008 06:33:00 -0700</pubDate><guid>https://freizl.github.io/posts/something-in-generic-programming/</guid><description>-- difference between raw type list and wildcard type list
You can put any element into a collection with a raw type, easily corrupting the collections type invariant. you cant put any element(other than null) into a Collection. Attempting to do so will generate a compile-time error message.
-- parametrized types are invariant.
In other words, for any two distinct types Type1 and Type2, Listis either a subtype nor a supertype of List.</description></item><item><title>JSE5, New Language Features Introduce by Joshua Bloch</title><link>https://freizl.github.io/posts/jse5-new-language-features-introduce-by/</link><pubDate>Mon, 07 Jul 2008 20:16:00 -0700</pubDate><guid>https://freizl.github.io/posts/jse5-new-language-features-introduce-by/</guid><description>(For me), it&amp;rsquo;s a good overview introduce of JSE5 new feature.
http://java.sun.com/features/2003/05/bloch_qa.html
Any other advance articles?</description></item><item><title>An Abstract Class when using DBUnit</title><link>https://freizl.github.io/posts/abstract-class-when-using-dbunit/</link><pubDate>Mon, 05 May 2008 01:32:00 -0700</pubDate><guid>https://freizl.github.io/posts/abstract-class-when-using-dbunit/</guid><description>http://sites.google.com/site/freizl/Home/java-code/sampledbunittest</description></item><item><title>Static Field/Method, Initialization Block Cont. (Java Disassemble)</title><link>https://freizl.github.io/posts/static-fieldmethod-initialization-block_20/</link><pubDate>Thu, 20 Mar 2008 06:08:00 -0700</pubDate><guid>https://freizl.github.io/posts/static-fieldmethod-initialization-block_20/</guid><description>Disassembles class files:
javap -c BaseObject</description></item><item><title>Static Field/Method, Initialization Block Cont. (Java Disassemble)</title><link>https://freizl.github.io/posts/static-fieldmethod-initialization-block_3944/</link><pubDate>Thu, 20 Mar 2008 06:08:00 -0700</pubDate><guid>https://freizl.github.io/posts/static-fieldmethod-initialization-block_3944/</guid><description>Disassembles class files:
javap -c BaseObject</description></item><item><title>Static Field/Method, Initialization Block Cont. (After compile)</title><link>https://freizl.github.io/posts/static-fieldmethod-initialization-block_19/</link><pubDate>Wed, 19 Mar 2008 19:14:00 -0700</pubDate><guid>https://freizl.github.io/posts/static-fieldmethod-initialization-block_19/</guid><description>package com.foo;
import java.io.PrintStream;
import org.apache.commons.lang.builder.ReflectionToStringBuilder;
public class BaseObject
{
private static long second = 0L;
private String name;
public BaseObject()
{
name = &amp;ldquo;&amp;rdquo;;
System.out.println(&amp;ldquo;I am class block initialization.&amp;rdquo;);
second++;
System.out.println(&amp;ldquo;I am constructor.&amp;rdquo;);
}
public BaseObject(String name)
{
this.name = &amp;ldquo;&amp;rdquo;;
System.out.println(&amp;ldquo;I am class block initialization.&amp;rdquo;);
this.name = name;
second++;
}
public String getName()
{
return name;
}
public void setName(String name)
{
this.name = name;
}
public static long getSecond()</description></item><item><title>Static Field/Method, Initialization Block (Java)</title><link>https://freizl.github.io/posts/static-fieldmethod-initialization-block/</link><pubDate>Wed, 19 Mar 2008 19:12:00 -0700</pubDate><guid>https://freizl.github.io/posts/static-fieldmethod-initialization-block/</guid><description>package com.foo;
import org.apache.commons.lang.builder.ReflectionToStringBuilder; public class BaseObject { /** a static field; all object of this class share this variable. */ private static long second = 0; private String name = &amp;ldquo;&amp;rdquo;; { System.out.println(&amp;ldquo;I am class block initialization.&amp;rdquo;); } static { System.out.println(&amp;ldquo;I am static block initialization.&amp;rdquo;); } public BaseObject() { super(); second++; System.out.println(&amp;ldquo;I am constructor.&amp;rdquo;); } public BaseObject(String name) { super(); this.name = name; second++; } public String getName() { return name; } public void setName(String name) { this.</description></item></channel></rss>