<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>haskell on Corner case</title><link>https://freizl.github.io/tags/haskell/</link><description>Recent content in haskell on Corner case</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Haisheng Wu</copyright><lastBuildDate>Wed, 12 Sep 2012 00:00:00 +0000</lastBuildDate><atom:link href="https://freizl.github.io/tags/haskell/index.xml" rel="self" type="application/rss+xml"/><item><title>Improve Space Usage</title><link>https://freizl.github.io/posts/improve-space-usage/</link><pubDate>Wed, 12 Sep 2012 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/improve-space-usage/</guid><description>It is example from programming in haskell video lecture 12 by Eric M. I just like to know whether GHC profile tool could help to figure out such problem.
module Main where sumWith1 v [] = v sumWith1 v (x:xs) = sumWith1 (v+x) xs sumWith2 v [] = v sumWith2 v (x:xs) = (sumWith2 $! (v+x)) xs test = sumWith2 0 [1..20000000] main = print test</description></item><item><title>Magic Monad Transformer</title><link>https://freizl.github.io/posts/magic-monad-transformer/</link><pubDate>Sat, 07 Apr 2012 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/magic-monad-transformer/</guid><description>Monad-Transformer The code fragment below is from chapter 18 Monad Transform of 1.
When the first time I read this example, I was confused with how it is possible to use ask of MonadReader (line 6) and get of MonadState (line 13) functions in the same App Monad content.
The only reasonable explanation is that App is both MonadReader and MonadState. While looking at App type definition (line 1), seems it is not possible.</description></item><item><title>Euler Problem 104</title><link>https://freizl.github.io/posts/euler-problem-104/</link><pubDate>Thu, 15 Dec 2011 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/euler-problem-104/</guid><description>Solutions There are two solutions below. One is written by me and another from haskell wiki.
They look quite similar and I can not figure out why the wiki solution can solve problem but not mine. (Actually mine take more than 15 minutes)
My Solution main = print $ snd $ head $ dropWhile (\ (x,y) -&amp;gt; (not . isLastNinePandigit &amp;#34;123456789&amp;#34;) x) (zip fibs [1..]) bothNinePandigit digits n = isFirstNinePandigit digits n &amp;amp;&amp;amp; isLastNinePandigit digits n isLastNinePandigit digits = (== digits) .</description></item><item><title>Euler Problem 14</title><link>https://freizl.github.io/posts/euler-problem-14/</link><pubDate>Sun, 20 Nov 2011 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/euler-problem-14/</guid><description>Solution One I should say this solution only work while upper limit is under 100000. Otherwise it is really slow and I have no patient for the result. I wonder it would take minutes or even hours.
So, problem solving failed.
module Main where import Data.Word main :: IO () main = print $ p14 p14 = maximum [ (startChain n 0, n) | n &amp;lt;- [2..1000000] ] startChain :: Int -&amp;gt; Int -&amp;gt; Int startChain 1 count = count + 1 startChain n count = startChain (intTransform n) (count+1) intTransform :: Int -&amp;gt; Int intTransform n | even n = n `div` 2 | otherwise = 3 * n + 1 Compile as otherwise Stack space overflow : ghc --make p14-1.</description></item><item><title>One Solution To Euler 12</title><link>https://freizl.github.io/posts/one-solution-to-euler-12/</link><pubDate>Fri, 18 Nov 2011 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/one-solution-to-euler-12/</guid><description>Nothing special but play haskell for fun.
Priming is a simple module which can be found atÂ 1
module Main where import Data.List import Primeing (primeFactors) main :: IO () main = print $ p12 500 p12 :: Int -&amp;gt; Int p12 n = head $ filter (factorLimit n) [ smartGaus x | x &amp;lt;- [1..]] smartGaus :: Int -&amp;gt; Int smartGaus n = (1+n)*n `div` 2 {-- | Is factor count under the limit --} factorLimit :: Int -&amp;gt; Int -&amp;gt; Bool factorLimit l n | 2 * sqrtInt n &amp;lt; l = False | otherwise = length (factors n) &amp;gt;= l factors :: Int -&amp;gt; [Int] factors n = concat [ [x, n `div` x] | x &amp;lt;- [1.</description></item><item><title>Type Parameter At Typeclass Instance</title><link>https://freizl.github.io/posts/type-parameter-at-typeclass-instance/</link><pubDate>Sat, 02 Jul 2011 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/type-parameter-at-typeclass-instance/</guid><description>A newbie concern A concern arise while I compare following two instances of Maybe.
class Eq a where (==) :: a -&amp;gt; a -&amp;gt; Bool (/=) :: a -&amp;gt; a -&amp;gt; Bool class Functor f where fmap :: (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b instance (Eq a) =&amp;gt; Eq (Maybe a) where Just x == Just y = x == y Nothing == Nothing = True _ == _ = False instance Functor Maybe where fmap f (Just x) = Just (f x) fmap f Nothing = Nothing It put Maybe as type parameter while instance Functor class.</description></item><item><title>Max File Size</title><link>https://freizl.github.io/posts/max-file-size/</link><pubDate>Tue, 21 Jun 2011 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/max-file-size/</guid><description>While doing some refactoring work on solution from this guy1, I realized a pretty trivial thing about Manod method &amp;gt;&amp;gt;=.
Take a look at its definition:
Prelude&amp;gt; :t (&amp;gt;&amp;gt;=) (&amp;gt;&amp;gt;=) :: (Monad m) =&amp;gt; m a -&amp;gt; (a -&amp;gt; m b) -&amp;gt; m b Both a and b ought to be some Monadic type! In other words, all computation glued together by &amp;gt;&amp;gt;= have same Manodic type.
It is really straightforward however I did not have that in mind.</description></item><item><title>Deriving</title><link>https://freizl.github.io/posts/deriving/</link><pubDate>Tue, 14 Jun 2011 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/deriving/</guid><description>Deriving What the cool thing that Deriving does is actually automaticlly implementing instance for perticular type class.
For instance, a Person derives Eq
data Person = Person { firstName :: String , lastName :: String , age :: Int } deriving Eq Then we are able to compare two Persons because Haskell make the type Person to be a instance of typeclass Eq.
Take another example,
data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday deriving (Bounded, Enum) The Bounded typeclass defines things that have lowest possible value and highest possible value.</description></item><item><title>MapM</title><link>https://freizl.github.io/posts/mapm/</link><pubDate>Tue, 14 Jun 2011 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/mapm/</guid><description>How to understand the following computation result? mapM id [Just 1, Nothing, Just 3] Reason about mapM :: (a -&amp;gt; m b) -&amp;gt; [a] -&amp;gt; m [b] id :: a -&amp;gt; a sequence :: (Monad m) =&amp;gt; [m a] -&amp;gt; m [a] Therefore,
&amp;gt; a = Maybe Int &amp;gt; m = Maybe &amp;gt; b = Int the mapM and sequence is implemented like this:
mapM f xs = sequence (map f xs) sequence (c:cs) = do x &amp;lt;- c xs &amp;lt;- sequence cs return (x:xs) Hence the result could be understood in such way</description></item><item><title>Understand Foldr Operator</title><link>https://freizl.github.io/posts/understand-foldr-operator/</link><pubDate>Sat, 04 Jun 2011 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/understand-foldr-operator/</guid><description>I can not quite remember the usage of foldr until I finish the video by Erik Meijer on Chapter 71.
Descrption by Erik Erik describe foldr in a very comprehensive way.
Take refining the length function in terms of foldr as a example. length has a definition as
&amp;gt; length :: [a] -&amp;gt; Int &amp;gt; length [] = 0 &amp;gt; length (x:xs) = 1 + length xs and
length [1,2,3] = length (1:(2:(3:[]))) = 1 + (1 + (1 + 0)) = 3 By replace each (:) by \ _ n -&amp;gt; 1 + n and [] by 0, we have:</description></item><item><title>Yet another Haskell toturial - Exercise 3</title><link>https://freizl.github.io/posts/exe-3/</link><pubDate>Sat, 04 Jun 2011 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/exe-3/</guid><description>The exercise asks writing a program that will repeatedly ask the user for numbers until she types in zero, at which point it will tell her the sum of all the numbers, the product of all the numbers, and, for each number, its factorial.
In the solution, I practice a idea that Monad is lazy as well. In other words, here, could generate a list of Monads then print out to console.</description></item><item><title>A Really Trivial Monad</title><link>https://freizl.github.io/posts/a-really-trivial-monad/</link><pubDate>Sun, 29 May 2011 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/a-really-trivial-monad/</guid><description>Generally some people saying that Monad is a computation that take a &amp;lsquo;world&amp;rsquo; as parameter and produce a result along with modified &amp;lsquo;world&amp;rsquo;. And this a manner that doing impure in a pure language.
While thinking in terms of Parser, it means taking a String and produce a result along with the rest of the string which is not parsed1. Consequently, we think a monadic type in Haskell is just a function.</description></item></channel></rss>