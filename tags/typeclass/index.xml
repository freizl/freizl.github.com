<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>typeclass on Corner case</title><link>https://freizl.github.io/tags/typeclass/</link><description>Recent content in typeclass on Corner case</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Haisheng Wu</copyright><lastBuildDate>Sat, 02 Jul 2011 00:00:00 +0000</lastBuildDate><atom:link href="https://freizl.github.io/tags/typeclass/index.xml" rel="self" type="application/rss+xml"/><item><title>Type Parameter At Typeclass Instance</title><link>https://freizl.github.io/posts/type-parameter-at-typeclass-instance/</link><pubDate>Sat, 02 Jul 2011 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/type-parameter-at-typeclass-instance/</guid><description>A newbie concern A concern arise while I compare following two instances of Maybe.
class Eq a where (==) :: a -&amp;gt; a -&amp;gt; Bool (/=) :: a -&amp;gt; a -&amp;gt; Bool class Functor f where fmap :: (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b instance (Eq a) =&amp;gt; Eq (Maybe a) where Just x == Just y = x == y Nothing == Nothing = True _ == _ = False instance Functor Maybe where fmap f (Just x) = Just (f x) fmap f Nothing = Nothing It put Maybe as type parameter while instance Functor class.</description></item><item><title>Deriving</title><link>https://freizl.github.io/posts/deriving/</link><pubDate>Tue, 14 Jun 2011 00:00:00 +0000</pubDate><guid>https://freizl.github.io/posts/deriving/</guid><description>Deriving What the cool thing that Deriving does is actually automaticlly implementing instance for perticular type class.
For instance, a Person derives Eq
data Person = Person { firstName :: String , lastName :: String , age :: Int } deriving Eq Then we are able to compare two Persons because Haskell make the type Person to be a instance of typeclass Eq.
Take another example,</description></item></channel></rss>