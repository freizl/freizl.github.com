<!doctype html><html lang=en-us>
<head>
<meta name=generator content="Hugo 0.88.1">
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta http-equiv=x-ua-compatible content="IE=edge">
<style type=text/css>body{font-family:monospace}</style>
<title>Corner case</title>
<link rel=stylesheet href=../../css/style.css>
<link rel=alternate type=application/rss+xml href=../../index.xml title="Corner case">
</head>
<body>
<header>
=================<br>
== <a href=https://freizl.github.io/>Corner case</a> ==<br>
=================
<div style=float:right>Welcome to my new blog!</div><br>
<p>
<nav>
<a href=../../><b>Start</b></a>.
</header>
<main>
<article>
<h1><a href=https://freizl.github.io/posts/max-file-size/>Max File Size</a></h1>
<b><time>06/21/2011</time></b>
<a href=../../tags/monad>monad</a>
<a href=../../tags/haskell>haskell</a>
<div>
While doing some refactoring work on solution from this guy1, I realized a pretty trivial thing about Manod method >>=.
Take a look at its definition:
Prelude> :t (>>=) (>>=) :: (Monad m) => m a -> (a -> m b) -> m b Both a and b ought to be some Monadic type! In other words, all computation glued together by >>= have same Manodic type.
It is really straightforward however I did not have that in mind.
<a href=https://freizl.github.io/posts/max-file-size/>Read more...</a>
</div>
</article>
<article>
<h1><a href=https://freizl.github.io/posts/deriving/>Deriving</a></h1>
<b><time>06/14/2011</time></b>
<a href=../../tags/typeclass>typeclass</a>
<a href=../../tags/deriving>deriving</a>
<a href=../../tags/haskell>haskell</a>
<div>
Deriving What the cool thing that Deriving does is actually automaticlly implementing instance for perticular type class.
For instance, a Person derives Eq
data Person = Person { firstName :: String , lastName :: String , age :: Int } deriving Eq Then we are able to compare two Persons because Haskell make the type Person to be a instance of typeclass Eq.
Take another example,
data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday deriving (Bounded, Enum) The Bounded typeclass defines things that have lowest possible value and highest possible value.
<a href=https://freizl.github.io/posts/deriving/>Read more...</a>
</div>
</article>
<article>
<h1><a href=https://freizl.github.io/posts/mapm/>MapM</a></h1>
<b><time>06/14/2011</time></b>
<a href=../../tags/monad>monad</a>
<a href=../../tags/haskell>haskell</a>
<div>
How to understand the following computation result? Prelude> mapM id [Just 1, Nothing, Just 3] Nothing &lsquo;Reason about&rsquo; mapM :: (a -> m b) -> [a] -> m [b] id :: a -> a sequence :: (Monad m) => [m a] -> m [a] Therefore,
> a = Maybe Int > m = Maybe > b = Int the mapM and sequence is implemented like this:
mapM f xs = sequence (map f xs) sequence (c:cs) = do x &lt;- c xs &lt;- sequence cs return (x:xs) Hence the result could be understood in such way
<a href=https://freizl.github.io/posts/mapm/>Read more...</a>
</div>
</article>
<article>
<h1><a href=https://freizl.github.io/posts/understand-foldr-operator/>Understand Foldr Operator</a></h1>
<b><time>06/04/2011</time></b>
<a href=../../tags/fold>fold</a>
<a href=../../tags/haskell>haskell</a>
<div>
I can not quite remember the usage of foldr until I finish the video by Erik Meijer on Chapter 71.
Descrption by Erik Erik describe foldr in a very comprehensive way.
Take refining the length function in terms of foldr as a example. length has a definition as
> length :: [a] -> Int > length [] = 0 > length (x:xs) = 1 + length xs and
length [1,2,3] = length (1:(2:(3:[]))) = 1 + (1 + (1 + 0)) = 3 By replace each (:) by \ _ n -> 1 + n and [] by 0, we have:
<a href=https://freizl.github.io/posts/understand-foldr-operator/>Read more...</a>
</div>
</article>
<article>
<h1><a href=https://freizl.github.io/posts/exe-3/>Yet another Haskell toturial - Exercise 3</a></h1>
<b><time>06/04/2011</time></b>
<a href=../../tags/haskell>haskell</a>
<div>
The exercise asks writing a program that will repeatedly ask the user for numbers until she types in zero, at which point it will tell her the sum of all the numbers, the product of all the numbers, and, for each number, its factorial.
In the solution, I practice a idea that Monad is lazy as well. In other words, here, could generate a list of Monads then print out to console.
<a href=https://freizl.github.io/posts/exe-3/>Read more...</a>
</div>
</article>
<article>
<h1><a href=https://freizl.github.io/posts/a-really-trivial-monad/>A Really Trivial Monad</a></h1>
<b><time>05/29/2011</time></b>
<a href=../../tags/haskell>haskell</a>
<a href=../../tags/monad>monad</a>
<div>
Generally some people saying that Monad is a computation that take a &lsquo;world&rsquo; as parameter and produce a result along with modified &lsquo;world&rsquo;. And this a manner that doing impure in a pure language.
While thinking in terms of Parser, it means taking a String and produce a result along with the rest of the string which is not parsed1. Consequently, we think a monadic type in Haskell is just a function.
<a href=https://freizl.github.io/posts/a-really-trivial-monad/>Read more...</a>
</div>
</article>
<div>
<a href=../../page/2/>Previous Page</a>
3 of 3
</div>
</main>
<footer>
<p>&copy; 2021 <a href=https://freizl.github.io/><b>Haisheng Wu</b></a>.
</p>
</footer>
</body>
</html>