<!doctype html><html lang=en-us>
<head>
<meta name=generator content="Hugo 0.88.1">
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta http-equiv=x-ua-compatible content="IE=edge">
<style type=text/css>body{font-family:monospace}</style>
<title>Corner case</title>
<link rel=stylesheet href=../../css/style.css>
<link rel=alternate type=application/rss+xml href=../../index.xml title="Corner case">
</head>
<body>
<header>
=================<br>
== <a href=https://freizl.github.io/>Corner case</a> ==<br>
=================
<div style=float:right>Welcome to my new blog!</div><br>
<p>
<nav>
<a href=../../><b>Start</b></a>.
</header>
<main>
<article>
<h1><a href=https://freizl.github.io/posts/euler-problem-14/>Euler Problem 14</a></h1>
<b><time>11/20/2011</time></b>
<a href=../../tags/euler>euler</a>
<a href=../../tags/haskell>haskell</a>
<div>
Solution One I should say this solution only work while upper limit is under 100000. Otherwise it is really slow and I have no patient for the result. I wonder it would take minutes or even hours.
So, problem solving failed.
module Main where import Data.Word main :: IO () main = print $ p14 p14 = maximum [ (startChain n 0, n) | n &lt;- [2..1000000] ] startChain :: Int -> Int -> Int startChain 1 count = count + 1 startChain n count = startChain (intTransform n) (count+1) intTransform :: Int -> Int intTransform n | even n = n `div` 2 | otherwise = 3 * n + 1 Compile as otherwise Stack space overflow : ghc --make p14-1.
<a href=https://freizl.github.io/posts/euler-problem-14/>Read more...</a>
</div>
</article>
<article>
<h1><a href=https://freizl.github.io/posts/one-solution-to-euler-12/>One Solution To Euler 12</a></h1>
<b><time>11/18/2011</time></b>
<a href=../../tags/euler>euler</a>
<a href=../../tags/haskell>haskell</a>
<div>
Nothing special but play haskell for fun.
Priming is a simple module which can be found atÂ 1
module Main where import Data.List import Primeing (primeFactors) main :: IO () main = print $ p12 500 p12 :: Int -> Int p12 n = head $ filter (factorLimit n) [ smartGaus x | x &lt;- [1..]] smartGaus :: Int -> Int smartGaus n = (1+n)*n `div` 2 {-- | Is factor count under the limit --} factorLimit :: Int -> Int -> Bool factorLimit l n | 2 * sqrtInt n &lt; l = False | otherwise = length (factors n) >= l factors :: Int -> [Int] factors n = concat [ [x, n `div` x] | x &lt;- [1.
<a href=https://freizl.github.io/posts/one-solution-to-euler-12/>Read more...</a>
</div>
</article>
<article>
<h1><a href=https://freizl.github.io/posts/type-parameter-at-typeclass-instance/>Type Parameter At Typeclass Instance</a></h1>
<b><time>07/02/2011</time></b>
<a href=../../tags/typeclass>typeclass</a>
<a href=../../tags/haskell>haskell</a>
<div>
A newbie concern A concern arise while I compare following two instances of Maybe.
class Eq a where (==) :: a -> a -> Bool (/=) :: a -> a -> Bool class Functor f where fmap :: (a -> b) -> f a -> f b instance (Eq a) => Eq (Maybe a) where Just x == Just y = x == y Nothing == Nothing = True _ == _ = False instance Functor Maybe where fmap f (Just x) = Just (f x) fmap f Nothing = Nothing It put Maybe as type parameter while instance Functor class.
<a href=https://freizl.github.io/posts/type-parameter-at-typeclass-instance/>Read more...</a>
</div>
</article>
<article>
<h1><a href=https://freizl.github.io/posts/max-file-size/>Max File Size</a></h1>
<b><time>06/21/2011</time></b>
<a href=../../tags/monad>monad</a>
<a href=../../tags/haskell>haskell</a>
<div>
While doing some refactoring work on solution from this guy1, I realized a pretty trivial thing about Manod method >>=.
Take a look at its definition:
Prelude> :t (>>=) (>>=) :: (Monad m) => m a -> (a -> m b) -> m b Both a and b ought to be some Monadic type! In other words, all computation glued together by >>= have same Manodic type.
It is really straightforward however I did not have that in mind.
<a href=https://freizl.github.io/posts/max-file-size/>Read more...</a>
</div>
</article>
<article>
<h1><a href=https://freizl.github.io/posts/deriving/>Deriving</a></h1>
<b><time>06/14/2011</time></b>
<a href=../../tags/typeclass>typeclass</a>
<a href=../../tags/deriving>deriving</a>
<a href=../../tags/haskell>haskell</a>
<div>
Deriving What the cool thing that Deriving does is actually automaticlly implementing instance for perticular type class.
For instance, a Person derives Eq
data Person = Person { firstName :: String , lastName :: String , age :: Int } deriving Eq Then we are able to compare two Persons because Haskell make the type Person to be a instance of typeclass Eq.
Take another example,
data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday deriving (Bounded, Enum) The Bounded typeclass defines things that have lowest possible value and highest possible value.
<a href=https://freizl.github.io/posts/deriving/>Read more...</a>
</div>
</article>
<article>
<h1><a href=https://freizl.github.io/posts/mapm/>MapM</a></h1>
<b><time>06/14/2011</time></b>
<a href=../../tags/monad>monad</a>
<a href=../../tags/haskell>haskell</a>
<div>
How to understand the following computation result? Prelude> mapM id [Just 1, Nothing, Just 3] Nothing &lsquo;Reason about&rsquo; mapM :: (a -> m b) -> [a] -> m [b] id :: a -> a sequence :: (Monad m) => [m a] -> m [a] Therefore,
> a = Maybe Int > m = Maybe > b = Int the mapM and sequence is implemented like this:
mapM f xs = sequence (map f xs) sequence (c:cs) = do x &lt;- c xs &lt;- sequence cs return (x:xs) Hence the result could be understood in such way
<a href=https://freizl.github.io/posts/mapm/>Read more...</a>
</div>
</article>
<article>
<h1><a href=https://freizl.github.io/posts/understand-foldr-operator/>Understand Foldr Operator</a></h1>
<b><time>06/04/2011</time></b>
<a href=../../tags/fold>fold</a>
<a href=../../tags/haskell>haskell</a>
<div>
I can not quite remember the usage of foldr until I finish the video by Erik Meijer on Chapter 71.
Descrption by Erik Erik describe foldr in a very comprehensive way.
Take refining the length function in terms of foldr as a example. length has a definition as
> length :: [a] -> Int > length [] = 0 > length (x:xs) = 1 + length xs and
length [1,2,3] = length (1:(2:(3:[]))) = 1 + (1 + (1 + 0)) = 3 By replace each (:) by \ _ n -> 1 + n and [] by 0, we have:
<a href=https://freizl.github.io/posts/understand-foldr-operator/>Read more...</a>
</div>
</article>
<article>
<h1><a href=https://freizl.github.io/posts/exe-3/>Yet another Haskell toturial - Exercise 3</a></h1>
<b><time>06/04/2011</time></b>
<a href=../../tags/haskell>haskell</a>
<div>
The exercise asks writing a program that will repeatedly ask the user for numbers until she types in zero, at which point it will tell her the sum of all the numbers, the product of all the numbers, and, for each number, its factorial.
In the solution, I practice a idea that Monad is lazy as well. In other words, here, could generate a list of Monads then print out to console.
<a href=https://freizl.github.io/posts/exe-3/>Read more...</a>
</div>
</article>
<article>
<h1><a href=https://freizl.github.io/posts/a-really-trivial-monad/>A Really Trivial Monad</a></h1>
<b><time>05/29/2011</time></b>
<a href=../../tags/haskell>haskell</a>
<a href=../../tags/monad>monad</a>
<div>
Generally some people saying that Monad is a computation that take a &lsquo;world&rsquo; as parameter and produce a result along with modified &lsquo;world&rsquo;. And this a manner that doing impure in a pure language.
While thinking in terms of Parser, it means taking a String and produce a result along with the rest of the string which is not parsed1. Consequently, we think a monadic type in Haskell is just a function.
<a href=https://freizl.github.io/posts/a-really-trivial-monad/>Read more...</a>
</div>
</article>
<div>
<a href=../../page/2/>Previous Page</a>
3 of 3
</div>
</main>
<footer>
<p>&copy; 2021 <a href=https://freizl.github.io/><b>Haisheng Wu</b></a>.
</p>
</footer>
</body>
</html>